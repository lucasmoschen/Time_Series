---
title: "Análise de intervenção e previsão de atividade econômica"
author: 
- Lucas Emanuel Resck Domingues^[Escola de Matemática Aplicada]
- Lucas Machado Moschen^[Escola de Matemática Aplicada]
output:
  pdf_document: default
---

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(ggplot2)
library(forecast)
library(TSA)
library(tseries)
```

# TODO

1. Fazer o processo de identificação manualmente para obter a primeira opção de modelo (mostrar que aprendemos isso).

2. Usar auto.arima para um segundo modelo. Se eles forem diferentes (o drift faz variar), comparamos os modelos usando alguma coisa (pensei no rollapply). Escolher o "melhor modelo"

3. Fazer previsões do modelo e comparar com pósintervenção. Vamos comparar com a realidade e verificar que de fato houve efeito. 

4. Fitar o modelo em todo o modelo: propor um modelo para a crise (talvez dois e repetir a escolha do melhor?)

5. Fazemos as previsões e avaliamos o modelo no teste (podemos comparar com um naive). 

Obs.: Esses 5 passos combrem a Metodologia, mas podemos adicionar algumas cerejas para deixar mais rico, dependendo do tempo. 




# Dados

A série temporal é o total de vendas mensais nos negócios em milhões de dólares, obtido em [Fred, Federal Reserve Bank of St. Louis](https://fred.stlouisfed.org/series/TOTBUSSMNSA). A janela de observações será entre Janeiro de 2002 a Dezembro de 2014, em que os últimos dois anos são utilizados para a validação do modelo de previsão. 

```{r, echo=F}
tbs <- read.csv("data/TOTBUSSMNSA.csv")
tbs <- ts(tbs$TOTBUSSMNSA, start = c(1992, 1), end = c(2020, 9), frequency = 12)
tbs <- window(tbs, start = c(2002, 1), end = c(2014, 12))

autoplot(tbs, main = "Total de vendas nos negócios", 
              xlab = "Tempo", 
              ylab = "Milhões de dólares") + 
  geom_vline(xintercept = (2008 + 7/12), 
             color = 'red', 
             linetype = "dashed", 
             size = 1) + 
  annotate(geom="text", x=2008, y=750000, label="Crise",
              color="red")
```

Vamos separar os últimos dois anos para validação do modelo e portanto, não usaremos no treinamento do modelo. 

```{r, echo=FALSE}
tbs_train <- window(tbs, start = c(2002, 1), end = c(2012,12))
tbs_test <- window(tbs, start = c(2013,1), end = c(2014,12))
```

Vamos considerar que houve uma intervenção (a crise sub-prime) em julho de 2008. 

# 1. Modelagem pré-intervenção 

Antes vamos fazer a modelagem do processo antes da crise. Assim, poderemos verificar que de fato houve efeito pós intervenção. 

```{r, echo=F}
pre_intervention <- window(tbs_train, start = c(2002,1), end = c(2008,6))
pos_intervention <- window(tbs_train, start = c(2008,7), end = c(2012,12))
```

Para isso, vamos seguir a metodologia Box-Jenkins. Primeiro, faremos uma transformação Box-Cox na série, se utilizando do $\lambda$ que minimiza o coeficiente de variação para subséries da série. 

```{r, echo=F}
lambda <- BoxCox.lambda(pre_intervention)
pre_intervention.bc <- BoxCox(pre_intervention, lambda)
print(paste("Obtemos lambda = ", lambda))
```

Agora, vamos remover a tendência diferenciando a série. 

```{r, echo=F}
pre_intervention.d = diff(pre_intervention.bc)
autoplot(pre_intervention.d, main = "Diferença mensal de vendas nos negócios", 
              xlab = "Tempo", 
              ylab = "Milhões de dólares")
```

Com a série diferenciada, vamos checar a sazonalidade anual, como sugerido: 

```{r, echo=F}
kruskal.test(pre_intervention.d,g = cycle(pre_intervention.d))
```

Como o p-valor é pequeno, temos evidência para rejeitar a hipótese nula do teste, o que nos dá suporte para diferenciar a série sazonalmente. Após a diferenciação, podemos ver que a ACF e a PACF não apresentam picos nos lags múltiplos de 12. 

```{r, echo=F}
pre_intervention.ds <- diff(pre_intervention.d, 12)
ggtsdisplay(pre_intervention.ds)
```

Assim, com o teste ADF rejeirando a não estacionaridade, podemos partir para identificar o modelo. 

```{r, echo=F}
adf.test(pre_intervention.bc)
```

Vemos uma ACF decaindo exponencialmente e uma PACF morrendo após o lag 2. Assim imaginamos um modelo AR com grau não maior do que 3. Vamos testar essa ideia com os critérios de informação. Além disso, não percebemos nenhum LAG significativo sazonal, o que pode indicar um MA(1) ou não ter componentes autorregressivos ou de média móvel sazonais. Vamos testar esses modelos também com os critérios de informação. O modelo de teste ARIMA(3,1,3) teve problema de estacionariedade e foi retirado da análise. 

```{r, echo = F}
ARMA.res <- data.frame()
## valor máximo de p,q.
K <- 3
L <- 2
for (p in 0:K) {
    for (q in 0:L) {
        model1 <- Arima(y = pre_intervention.bc, order = c(p, 1, q), seasonal = c(0,1,0))
        model2 <- Arima(y = pre_intervention.bc, order = c(p, 1, q), seasonal = c(0,1,1))
        ARMA.res <- rbind(ARMA.res, c(p,q,model1$aic, model1$bic, model1$aicc,
                                          model2$aic, model2$bic, model2$aicc))
    }
}
names(ARMA.res) = c('p', 'q','AIC', 'BIC', 'AICc', 'AIC (S)', 'BIC (S)', 'AICc (S)')
```

Podemos observar que sem sazonalidade, o melhor modelo segundo os três critérios de informação foi ARMA(2,0) como já tínhamos imaginado. Considerando a sazonalidade, o melhor modelo fica, ao todo 

ARIMA(2,1,0)(0,1,1)[12]

```{r}
print(ARMA.res)
```

Agora que já identificamos o modelo, podemos estimá-lo. 

```{r, echo=FALSE}
model1 <- Arima(pre_intervention, 
                order = c(2,1,0), 
                seasonal = c(0,1,1),
                lambda = "auto")
summary(model1)
```

Agora com o modelo treinado, podemos fazer uma checagem sobre os resíduos: 

```{r}
checkresiduals(model1)
jarque.bera.test(model1$residuals)
```

Observamos que existe um resíduo bem deslocado que no ano de 2003 quando houve uma queda que o modelo não conseguiu capturar. Além disso, não aparenta uma normalidade, inclusive tendo-a rejeitada pelo teste Jarque-Bera. Por fim, as correlações estão bem interessantes, dentro das margens e, o teste de Ljung-Box não rejeitou a hipótese de descorrelação. Isso é um bom indício, porém a não normalidade dos dados indica algum problema.  

Vamos averiguar uma segunda opção de modelo que pode ser encontrada automaticamente, utilizando a função `auto.arima`. Assim, vemos que o modelo estimado tem drift e é do tipo 

ARIMA(3,0,0)(2,1,0)[12]. 

```{r, echo=FALSE}
model2 <- auto.arima(pre_intervention, 
           lambda = "auto")
model2 <- Arima(pre_intervention, 
                order = c(3,0,0), 
                seasonal = c(2,1,0), 
                include.drift = TRUE, 
                lambda = "auto")
summary(model2)
```

